let SAMPLES = {};

let shortcutjs = season.shortcut;

SAMPLES.code = `# batch api
def process(data, **opts):
    return data
`;

const LOCALSTORAGEID = "dizest.configuration";
const TABS = ['code', 'api', 'pug', 'js', 'css', "preview"];
const CODELIST = [
    { id: 'code', name: 'Batch API' },
    { id: 'api', name: 'API' },
    { id: 'pug', name: 'PUG' },
    { id: 'js', name: 'JS' },
    { id: 'css', name: 'SCSS' },
    { id: 'preview', name: 'Preview' }
];

const ROOM = wiz.data.mode + "/" + wiz.data.namespace;
let PREVIEW_URL = async (stage_id) => {
    return "/dizest/preview/" + wiz.data.mode + "/" + wiz.data.namespace + "/" + stage_id;
}

let wiz_controller = async ($sce, $scope, $timeout) => {
    let monaco_option = (language) => {
        let opt = {
            value: '',
            language: language,
            theme: "vs",
            fontSize: 14,
            automaticLayout: true,
            minimap: {
                enabled: false
            }
        };

        return opt;
    }

    const $_timeout = $timeout;
    $timeout = (ts) => new Promise((resolve) => $_timeout(resolve, ts));

    let WIZAPI = async (url, data) => {
        if (!data) data = {};
        data.namespace = wiz.data.namespace;
        data.mode = wiz.data.mode;
        return await wiz.API.async(url, data);
    };

    /*
     * define variables of scope
     */
    $scope.math = Math;
    $scope.trustAsHtml = $sce.trustAsHtml;
    $scope.configuration = {};
    $scope.layout = {};
    $scope.loading = {};
    $scope.modal = {};
    $scope.plugin = {};

    $scope.workspace = {};
    $scope.app = {};
    $scope.dizest = {};

    $scope.wizdata = wiz.data;

    $scope.shortcut = {};
    $scope.socket = {};

    $scope.sortable_opt = {
        items: '.sortable-item',
        'ui-floating': true
    }

    /* 
     * load wiz editor options from localstorage
     */
    try {
        let configuration = JSON.parse(localStorage[LOCALSTORAGEID]);
        try { delete configuration.layout.opts.root.lastComponentSize; } catch (e) { }
        $scope.configuration = configuration;
    } catch (e) {
        $scope.configuration = {};
        $scope.configuration.tab = {};
        $scope.configuration.tab['tab1_val'] = TABS[0];
        $scope.configuration.tab['tab2_val'] = TABS[1];
        $scope.configuration.tab['tab3_val'] = TABS[2];
        $scope.configuration.tab['tab4_val'] = 'debug';
        $scope.configuration.layout = 2;
        $scope.configuration.layout_menu_width = 360;
    }

    if ($scope.configuration.layout_menu_width == 0)
        $scope.configuration.layout_menu_width = 360;

    $scope.$watch("configuration", function () {
        let configuration = angular.copy($scope.configuration);
        localStorage[LOCALSTORAGEID] = JSON.stringify(configuration);
    }, true);

    let BUILDER = {};

    /* 
     * layout selector using split pane
     */
    BUILDER.layout = async () => {
        $scope.layout.viewstate = {};
        $scope.layout.viewstate.root = { firstComponentSize: $scope.configuration.layout_menu_width };
        $scope.layout.viewstate.horizonal = {};
        $scope.layout.viewstate.vertical_1_1 = {};
        $scope.layout.viewstate.vertical_1_2 = {};
        $scope.layout.active_layout = $scope.configuration.layout;

        $scope.$watch("layout", function () {
            $scope.configuration.layout_menu_width = $scope.layout.viewstate.root.firstComponentSize;
            $scope.configuration.layout = $scope.layout.active_layout;
        }, true);

        $scope.layout.change = async (layout) => {
            $scope.layout.active_layout = layout;

            if (layout == 1) {
                $scope.layout.accessable_tab = ['tab1'];
            } else if (layout == 2) {
                $scope.layout.accessable_tab = ['tab1', 'tab2'];
            } else if (layout == 3) {
                $scope.layout.accessable_tab = ['tab1', 'tab2', 'tab3'];
            } else if (layout == 4) {
                $scope.layout.accessable_tab = ['tab1'];
            } else if (layout == 5) {
                $scope.layout.accessable_tab = ['tab1', 'tab2'];
            } else if (layout == 6) {
                $scope.layout.accessable_tab = ['tab1', 'tab2', 'tab3'];
            }

            let _height = $('#editor-area').height();
            let _width = $('#editor-area').width();

            function _horizonal_split() {
                var h = Math.round(_height / 3);
                if (h > 400) h = 400;
                $scope.layout.viewstate.horizonal.lastComponentSize = h;
            }

            function _horizonal_top() {
                $scope.layout.viewstate.horizonal.lastComponentSize = 0;
            }

            if (layout == 1) {
                _horizonal_top();
                $scope.layout.viewstate.vertical_1_1.lastComponentSize = 0;
            } else if (layout == 2) {
                _horizonal_top();
                $scope.layout.viewstate.vertical_1_1.lastComponentSize = Math.round(_width / 2);
                $scope.layout.viewstate.vertical_1_2.lastComponentSize = 0;
            } else if (layout == 3) {
                _horizonal_top();
                $scope.layout.viewstate.vertical_1_1.lastComponentSize = Math.round(_width / 3 * 2);
                $scope.layout.viewstate.vertical_1_2.lastComponentSize = Math.round(_width / 3);
            } else if (layout == 4) {
                _horizonal_split();
                $scope.layout.viewstate.vertical_1_1.firstComponentSize = _width;
                $scope.layout.viewstate.vertical_1_1.lastComponentSize = 0;
            } else if (layout == 5) {
                _horizonal_split();
                $scope.layout.viewstate.vertical_1_1.firstComponentSize = Math.round(_width / 2);
                $scope.layout.viewstate.vertical_1_1.lastComponentSize = Math.round(_width / 2);
                $scope.layout.viewstate.vertical_1_2.firstComponentSize = Math.round(_width / 2);
                $scope.layout.viewstate.vertical_1_2.lastComponentSize = 0;
            } else if (layout == 6) {
                _horizonal_split();
                $scope.layout.viewstate.vertical_1_1.firstComponentSize = Math.round(_width / 3);
                $scope.layout.viewstate.vertical_1_1.lastComponentSize = Math.round(_width / 3 * 2);
                $scope.layout.viewstate.vertical_1_2.firstComponentSize = Math.round(_width / 3);
                $scope.layout.viewstate.vertical_1_2.lastComponentSize = Math.round(_width / 3);
            }

            await $timeout();
        }
    }

    /*
     * define loading
     */
    BUILDER.loading = async () => {
        $scope.loading.status = false;
        $scope.loading.show = async () => {
            $scope.loading.status = true;
            await $timeout();
        }

        $scope.loading.hide = async () => {
            $scope.loading.status = false;
            await $timeout();
        }
    }

    /*
     * define modal events
     */

    BUILDER.modal = async () => {
        $scope.modal.delete = async (mode) => {
            $scope.modal.delete.mode = mode;
            $('#modal-delete').modal('show');
        }

        $scope.modal.add_language = async () => {
            $('#modal-add-language').modal('show');
        }

        $scope.modal.keymaps = function () {
            $('#modal-keymaps').modal('show');
        }
    }

    /*
     * define plugin interfaces for wiz
     */

    BUILDER.plugin = async () => {
        $scope.plugin.editor = {};
        $scope.plugin.editor.build = async (targettab, editor) => {
            let shortcuts = $scope.shortcut.configuration(window.monaco);

            for (let shortcutname in shortcuts) {
                let monacokey = shortcuts[shortcutname].monaco;
                let fn = shortcuts[shortcutname].fn;
                if (!monacokey) continue;

                editor.addCommand(monacokey, async () => {
                    await fn();
                    await $scope.shortcut.bind();
                });
            }
        }
    }

    BUILDER.workspace = async () => {
        if (!$scope.configuration.workspace)
            $scope.configuration.workspace = 'tab2';
        $scope.workspace.active = async (tab) => {
            $scope.configuration.workspace = tab;
            await $timeout();
        }
    }

    /*
     * define app controller
     */

    BUILDER.app = {};

    BUILDER.app.base = async () => {
        $scope.app.tab = {};
        $scope.app.tab.active = async (tab) => {
            $scope.app.tab.activetab = tab;
            await $timeout();
        }

        $scope.app.load = async (item) => {
            // show loading
            await $scope.loading.show();

            // load data
            $scope.app.data = item;
            await $scope.app.editor.build();
            await $scope.layout.change($scope.layout.active_layout);
            await $scope.loading.hide();

            await $scope.app.preview();

            await $timeout(500);

            if ($scope.app.tab.activetab && $scope.app.editor.cache[$scope.app.tab.activetab])
                $scope.app.editor.cache[$scope.app.tab.activetab].focus();
        }

        $scope.app.preview = async () => {
            if (!$scope.app.data) return;
            let stage_id = $scope.app.data.id;
            if (!stage_id) return;

            let url = await PREVIEW_URL(stage_id);
            $scope.app.preview.status = false;
            await $timeout();

            $('iframe.preview').attr('src', url);
            $('iframe.preview').on('load', function () {
                $scope.app.preview.status = true;
                $timeout();
            });
        }
    }

    BUILDER.app.editor = async () => {
        $scope.app.editor = {};
        $scope.app.editor.cache = {};
        $scope.app.editor.properties = {};
        $scope.app.editor.code = {};

        $scope.app.editor.code.list = CODELIST;

        $scope.app.editor.code.dic = {};
        $scope.app.editor.code.dic.add = async (lang) => {
            if (!lang || lang.length < 2) {
                toastr.error("at least 2 char");
                return;
            }
            lang = lang.toLowerCase();
            $scope.app.data.dic[lang] = "{}";
            $('#modal-add-language').modal('hide');
            await $timeout();
        }

        $scope.app.editor.code.langselect = async (tab) => {
            let obj = $scope.configuration.tab[tab + '_val'];
            if (obj == 'css') return 'scss';
            if (obj == 'pug') return 'pug';
            if (obj == 'js') return 'javascript';
            return 'python';
        }

        $scope.app.editor.code.change = async (targettab, view) => {
            if (view) {
                $scope.configuration.tab[targettab + '_val'] = view;
                await $timeout();

                if (view == 'preview') {
                    $scope.app.preview();
                    return;
                }

                if (view == 'debug') {
                    return;
                };

                let language = $scope.app.editor.properties[targettab].language = await $scope.app.editor.code.langselect(targettab);

                if ($scope.app.editor.cache[targettab]) {
                    let model = $scope.app.editor.cache[targettab].getModel();
                    monaco.editor.setModelLanguage(model, language);

                    $scope.app.editor.cache[targettab].focus();
                }
            } else {
                if ($scope.app.tab.activetab != targettab) {
                    $scope.app.tab.activetab = targettab;
                    await $timeout();
                    await $timeout(500);
                    $scope.app.editor.cache[targettab].focus();
                }
            }
        }

        $scope.app.editor.code.prev = async () => {
            if (!$scope.layout.accessable_tab) return;
            let tab = 'tab1';
            if ($scope.app.tab.activetab) tab = $scope.app.tab.activetab;

            tab = $scope.layout.accessable_tab.indexOf(tab) - 1;
            if (tab < 0) tab = $scope.layout.accessable_tab.length - 1;
            tab = $scope.layout.accessable_tab[tab];
            let view = $scope.configuration.tab[tab + '_val']

            while (view == 'preview') {
                tab = $scope.layout.accessable_tab.indexOf(tab) - 1;
                if (tab < 0) tab = $scope.layout.accessable_tab.length - 1;
                tab = $scope.layout.accessable_tab[tab];
                view = $scope.configuration.tab[tab + '_val']
            }

            $scope.app.editor.code.change(tab);
            $scope.app.editor.cache[tab].focus();
        }

        $scope.app.editor.code.next = async () => {
            if (!$scope.layout.accessable_tab) return;
            let tab = 'tab1';
            if ($scope.app.tab.activetab) tab = $scope.app.tab.activetab;

            tab = $scope.layout.accessable_tab.indexOf(tab) + 1;
            tab = tab % $scope.layout.accessable_tab.length;
            tab = $scope.layout.accessable_tab[tab];
            let view = $scope.configuration.tab[tab + '_val']

            while (view == 'preview') {
                tab = $scope.layout.accessable_tab.indexOf(tab) + 1;
                tab = tab % $scope.layout.accessable_tab.length;
                tab = $scope.layout.accessable_tab[tab];
                view = $scope.configuration.tab[tab + '_val']
            }

            $scope.app.editor.code.change(tab);
            $scope.app.editor.cache[tab].focus();
        }

        $scope.app.editor.build = async () => {
            $scope.app.editor.viewstate = false;
            await $timeout();

            $scope.app.editor.properties.tab1 = monaco_option(await $scope.app.editor.code.langselect('tab1'));
            $scope.app.editor.properties.tab2 = monaco_option(await $scope.app.editor.code.langselect('tab2'));
            $scope.app.editor.properties.tab3 = monaco_option(await $scope.app.editor.code.langselect('tab3'));

            let bindonload = async (targettab) => {
                $scope.app.editor.properties[targettab].onLoad = async (editor) => {
                    await $scope.plugin.editor.build(targettab, editor);
                    $scope.app.editor.cache[targettab] = editor;
                }
            }

            for (var i = 1; i <= 3; i++)
                bindonload('tab' + i);

            $scope.app.editor.viewstate = true;
            await $timeout();
        }

    }

    BUILDER.dizest = async () => {
        $scope.dizest.create = async () => {
            $scope.dizest.data.stage.push({
                title: 'new stage',
                id: '',
                code: SAMPLES.code
            });
        }

        $scope.dizest.modal_close = async () => {
            await $timeout();
            $('#modal-delete').modal('hide');
        }

        $scope.dizest.delete = async () => {
            if (!$scope.modal.delete.mode) {
                let data = angular.copy($scope.dizest.data);
                await WIZAPI("delete", { data: JSON.stringify(data) });
                location.href = "/";
            } else {
                $scope.dizest.data.stage.remove($scope.modal.delete.mode);
            }

            await $timeout();
            $('#modal-delete').modal('hide');
        }

        $scope.dizest.save = async (returnres) => {
            let data = angular.copy($scope.dizest.data);
            let res = await WIZAPI("update", { data: JSON.stringify(data) });
            if (returnres) return res;

            if (res.code == 200) {
                toastr.success("Saved");
                await $scope.app.preview();
            } else {
                toastr.error(res.data);
            }

            await $scope.shortcut.bind();
        }

        $scope.dizest.load = async () => {
            let res = await WIZAPI("workspace");
            $scope.dizest.data = res.data;

            if (!$scope.dizest.data.id) {
                $scope.dizest.data.id = wiz.data.namespace;
            }

            if (!$scope.dizest.data.stage) {
                $scope.dizest.data.stage = [];
            }

            await $timeout();
        }

        $scope.dizest.select = async (item) => {
            await $scope.app.load(item);
        }

        $scope.dizest.next = async () => {
            if ($scope.dizest.data.stage.length <= 1) return;
            let index = $scope.dizest.data.stage.indexOf($scope.app.data);
            if ($scope.dizest.data.stage[index + 1])
                return await $scope.app.load($scope.dizest.data.stage[index + 1]);
            return await $scope.app.load($scope.dizest.data.stage[0]);
        }

        $scope.dizest.prev = async () => {
            let index = $scope.dizest.data.stage.indexOf($scope.app.data);
            if ($scope.dizest.data.stage[index - 1])
                return await $scope.app.load($scope.dizest.data.stage[index - 1]);

            index = $scope.dizest.data.stage.length - 1;
            return await $scope.app.load($scope.dizest.data.stage[index]);
        }
    }

    BUILDER.shortcuts = async () => {
        $scope.shortcut.configuration = (monaco) => {
            return {
                'editor_prev': {
                    monaco: monaco.KeyMod.Alt | monaco.KeyCode.KEY_A,
                    fn: async () => {
                        let targettab = $scope.app.tab.activetab;
                        var prev = TABS.indexOf($scope.configuration.tab[targettab + "_val"]) - 1;
                        if (prev < 0) prev = TABS[TABS.length - 1];
                        else prev = TABS[prev];

                        if (prev == 'preview') {
                            prev = TABS.indexOf(prev) - 1;
                            if (prev < 0) prev = TABS[TABS.length - 1];
                            else prev = TABS[prev];
                        }

                        await $scope.app.editor.code.change(targettab, prev);
                        await $scope.shortcut.bind();
                    }
                },
                'editor_next': {
                    monaco: monaco.KeyMod.Alt | monaco.KeyCode.KEY_S,
                    fn: async () => {
                        let targettab = $scope.app.tab.activetab;
                        var next = TABS[(TABS.indexOf($scope.configuration.tab[targettab + "_val"]) + 1) % TABS.length];
                        if (next == 'preview') {
                            next = TABS[(TABS.indexOf(next) + 1) % TABS.length];
                        }
                        await $scope.app.editor.code.change(targettab, next);
                        await $scope.shortcut.bind();
                    }
                },
                'app_prev': {
                    key: 'Alt KeyJ',
                    monaco: monaco.KeyMod.Alt | monaco.KeyCode.KEY_J,
                    fn: async () => {
                        $(window).focus();
                        await $scope.dizest.prev();
                    }
                },
                'app_next': {
                    key: 'Alt KeyK',
                    monaco: monaco.KeyMod.Alt | monaco.KeyCode.KEY_K,
                    fn: async () => {
                        $(window).focus();
                        await $scope.dizest.next();
                    }
                },
                'workspace_prev': {
                    key: 'Alt KeyZ',
                    monaco: monaco.KeyMod.Alt | monaco.KeyCode.KEY_Z,
                    fn: async () => {
                        await $scope.app.editor.code.prev();
                    }
                },
                'workspace_next': {
                    key: 'Alt KeyX',
                    monaco: monaco.KeyMod.Alt | monaco.KeyCode.KEY_X,
                    fn: async () => {
                        await $scope.app.editor.code.next();
                    }
                },
                'save': {
                    key: 'Ctrl KeyS',
                    monaco: monaco.KeyMod.CtrlCmd | monaco.KeyCode.KEY_S,
                    fn: async () => {
                        await $scope.dizest.save();
                    }
                },
                'clear': {
                    key: 'Ctrl KeyK',
                    monaco: monaco.KeyMod.CtrlCmd | monaco.KeyCode.KEY_K,
                    fn: async () => {
                        await $scope.socket.clear();
                    }
                }
            }
        };

        $scope.shortcut.bind = async () => {
            if (!window.monaco) return;
            $(window).unbind();

            let shortcut_opts = {};
            let shortcuts = $scope.shortcut.configuration(window.monaco);
            for (let key in shortcuts) {
                let keycode = shortcuts[key].key;
                let fn = shortcuts[key].fn;
                if (!keycode) continue;
                shortcut_opts[keycode] = async (ev) => {
                    ev.preventDefault();
                    await fn();
                };
            }

            shortcutjs(window, shortcut_opts);
        }

        window.addEventListener("focus", $scope.shortcut.bind, false);
    }

    await BUILDER.loading();
    await BUILDER.layout();
    await BUILDER.plugin();
    await BUILDER.modal();

    await BUILDER.workspace();

    await BUILDER.dizest();

    await BUILDER.app.base();
    await BUILDER.app.editor();

    await BUILDER.shortcuts();

    let init = async () => {
        await $scope.dizest.load();
        if ($scope.dizest.data.stage.length > 0)
            await $scope.dizest.select($scope.dizest.data.stage[0]);

        $scope.import_file = function () {
            $('#import-file').click();
        }

        $('#import-file').change(async () => {
            let fr = new FileReader();
            fr.onload = async () => {
                let data = fr.result;
                data = JSON.parse(data);
                data.id = $scope.dizest.data.id;
                $scope.dizest.data = data;
                $scope.dizest.save();
                await $timeout();
            };
            fr.readAsText($('#import-file').prop('files')[0]);
        });

        /*
         * socket.io event binding for trace log
         */
        let ansi_up = new AnsiUp();

        let socket = wiz.socket.get();

        $scope.socket.log = "";
        $scope.socket.clear = async () => {
            $scope.socket.log = "";
            await $timeout();
        }

        socket.on("connect", async () => {
            if ($scope.configuration.layout > 3) {
                socket.emit("join", { id: ROOM });
            }
        });

        socket.on("log", async (data) => {
            data = data.replace(/ /gim, "__SEASONWIZPADDING__");
            data = ansi_up.ansi_to_html(data).replace(/\n/gim, '<br>').replace(/__SEASONWIZPADDING__/gim, '<div style="width: 6px; display: inline-block;"></div>');
            $scope.socket.log = $scope.socket.log + data;

            await $timeout();

            let element = $('.dizest-debug-messages')[0];
            if (!element) return;
            element.scrollTop = element.scrollHeight - element.clientHeight;
        });

        $scope.$watch("configuration", async () => {
            let layout = $scope.configuration.layout;
            if (layout < 4) {
                socket.emit("leave", { id: ROOM });
            } else {
                socket.emit("join", { id: ROOM });
            }
        }, true);
    }

    init();
}