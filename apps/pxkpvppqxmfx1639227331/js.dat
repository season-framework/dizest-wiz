const LOCALSTORAGEID = "dizest.configuration";
const TABS = ['dataset', 'api', 'html', 'js', 'css', "preview"];
const CODELIST = [
    { id: 'dataset', name: 'Dataset' },
    { id: 'api', name: 'API' },
    { id: 'html', name: 'HTML' },
    { id: 'js', name: 'JS' },
    { id: 'css', name: 'CSS' },
    { id: 'preview', name: 'Preview' }
];

let PREVIEW_URL = async (app_id) => {
    return wiz.API.url("preview/" + app_id);
}

let wiz_controller = async ($sce, $scope, $timeout) => {
    _builder($scope, $timeout);
    const timeout = (ts) => new Promise((resolve) => $timeout(resolve, ts));

    let hash = location.hash.split("#")[1];

    /*
     * define variables of scope
     */
    $scope.math = Math;
    $scope.trustAsHtml = $sce.trustAsHtml;
    $scope.configuration = {};       // state data for maintaining ui
    $scope.layout = {};              // controller for layout
    $scope.loading = {};             // controller for display loading
    $scope.modal = {};               // controller for modal
    $scope.plugin = {};              // manage plugins for ui components

    $scope.workspace = {};
    $scope.app = {};                 // controller for code editor
    $scope.dataset = {};            // controller for code editor

    $scope.shortcut = {};
    $scope.socket = {};

    $scope.sortable_opt = {
        // update: function () {
        //     $timeout(function () {
        //         $scope.event.save(function () {
        //             $scope.iframe.loader($scope.selected_app);
        //         });
        //     });
        // },
        items: '.sortable-item',
        'ui-floating': true
    }

    /* 
     * load wiz editor options from localstorage
     */
    try {
        let configuration = JSON.parse(localStorage[LOCALSTORAGEID]);
        try { delete configuration.layout.opts.root.lastComponentSize; } catch (e) { }
        $scope.configuration = configuration;
    } catch (e) {
        $scope.configuration = {};
        $scope.configuration.tab = {};
        $scope.configuration.tab['tab1_val'] = TABS[0];
        $scope.configuration.tab['tab2_val'] = TABS[1];
        $scope.configuration.tab['tab3_val'] = TABS[2];
        $scope.configuration.tab['tab4_val'] = 'debug';
        $scope.configuration.layout = 2;
        $scope.configuration.layout_menu_width = 360;
    }

    if ($scope.configuration.layout_menu_width == 0)
        $scope.configuration.layout_menu_width = 360;

    $scope.$watch("configuration", function () {
        let configuration = angular.copy($scope.configuration);
        localStorage[LOCALSTORAGEID] = JSON.stringify(configuration);
    }, true);

    /*
     * define variables
     */
    let BUILDER = {};

    /* 
     * layout selector using split pane
     */
    BUILDER.layout = async () => {
        $scope.layout.viewstate = {};
        $scope.layout.viewstate.root = { firstComponentSize: $scope.configuration.layout_menu_width };
        $scope.layout.viewstate.horizonal = {};
        $scope.layout.viewstate.vertical_1_1 = {};
        $scope.layout.viewstate.vertical_1_2 = {};
        $scope.layout.active_layout = $scope.configuration.layout;

        $scope.$watch("layout", function () {
            $scope.configuration.layout_menu_width = $scope.layout.viewstate.root.firstComponentSize;
            $scope.configuration.layout = $scope.layout.active_layout;
        }, true);

        $scope.layout.change = async (layout) => {
            $scope.layout.active_layout = layout;

            if (layout == 1) {
                $scope.layout.accessable_tab = ['tab1'];
            } else if (layout == 2) {
                $scope.layout.accessable_tab = ['tab1', 'tab2'];
            } else if (layout == 3) {
                $scope.layout.accessable_tab = ['tab1', 'tab2', 'tab3'];
            } else if (layout == 4) {
                $scope.layout.accessable_tab = ['tab1'];
            } else if (layout == 5) {
                $scope.layout.accessable_tab = ['tab1', 'tab2'];
            } else if (layout == 6) {
                $scope.layout.accessable_tab = ['tab1', 'tab2', 'tab3'];
            }

            let _height = $('#editor-area').height();
            let _width = $('#editor-area').width();

            function _horizonal_split() {
                var h = Math.round(_height / 3);
                if (h > 400) h = 400;
                $scope.layout.viewstate.horizonal.lastComponentSize = h;
            }

            function _horizonal_top() {
                $scope.layout.viewstate.horizonal.lastComponentSize = 0;
            }

            if (layout == 1) {
                _horizonal_top();
                $scope.layout.viewstate.vertical_1_1.lastComponentSize = 0;
            } else if (layout == 2) {
                _horizonal_top();
                $scope.layout.viewstate.vertical_1_1.lastComponentSize = Math.round(_width / 2);
                $scope.layout.viewstate.vertical_1_2.lastComponentSize = 0;
            } else if (layout == 3) {
                _horizonal_top();
                $scope.layout.viewstate.vertical_1_1.lastComponentSize = Math.round(_width / 3 * 2);
                $scope.layout.viewstate.vertical_1_2.lastComponentSize = Math.round(_width / 3);
            } else if (layout == 4) {
                _horizonal_split();
                $scope.layout.viewstate.vertical_1_1.firstComponentSize = _width;
                $scope.layout.viewstate.vertical_1_1.lastComponentSize = 0;
            } else if (layout == 5) {
                _horizonal_split();
                $scope.layout.viewstate.vertical_1_1.firstComponentSize = Math.round(_width / 2);
                $scope.layout.viewstate.vertical_1_1.lastComponentSize = Math.round(_width / 2);
                $scope.layout.viewstate.vertical_1_2.firstComponentSize = Math.round(_width / 2);
                $scope.layout.viewstate.vertical_1_2.lastComponentSize = 0;
            } else if (layout == 6) {
                _horizonal_split();
                $scope.layout.viewstate.vertical_1_1.firstComponentSize = Math.round(_width / 3);
                $scope.layout.viewstate.vertical_1_1.lastComponentSize = Math.round(_width / 3 * 2);
                $scope.layout.viewstate.vertical_1_2.firstComponentSize = Math.round(_width / 3);
                $scope.layout.viewstate.vertical_1_2.lastComponentSize = Math.round(_width / 3);
            }

            await timeout();
        }
    }

    /*
     * define loading
     */
    BUILDER.loading = async () => {
        $scope.loading.status = false;
        $scope.loading.show = async () => {
            $scope.loading.status = true;
            await timeout();
        }

        $scope.loading.hide = async () => {
            $scope.loading.status = false;
            await timeout();
        }
    }

    /*
     * define modal events
     */

    BUILDER.modal = async () => {
        $scope.modal.delete = async () => {
            $('#modal-delete').modal('show');
        }

        $scope.modal.add_language = async () => {
            $('#modal-add-language').modal('show');
        }

        $scope.modal.keymaps = function () {
            $('#modal-keymaps').modal('show');
        }
    }

    /*
     * define plugin interfaces for wiz
     */

    BUILDER.plugin = async () => {
        $scope.plugin.editor = {};
        $scope.plugin.editor.build = async (targettab, editor) => {
            let shortcuts = $scope.shortcut.configuration(window.monaco);

            for (let shortcutname in shortcuts) {
                let monacokey = shortcuts[shortcutname].monaco;
                let fn = shortcuts[shortcutname].fn;
                if (!monacokey) continue;

                editor.addCommand(monacokey, async () => {
                    await fn();
                    await $scope.shortcut.bind();
                });
            }
        }
    }

    BUILDER.workspace = async() => {
        $scope.workspace.activated = 'tab1';
        $scope.workspace.active = async(tab) =>{
            $scope.workspace.activated = tab;
            await timeout();
        }
    }

    /*
     * define app controller
     */

    BUILDER.app = {};

    BUILDER.app.base = async () => {
        $scope.app.save = async (returnres) => {
            let appdata = angular.copy($scope.app.data);
            console.log(appdata);

            // let res = await API.update(appdata);

            // if (returnres) return res;

            // if (res.code == 200) {
            // toastr.success("Saved");
            // await $scope.app.preview();
            // } else {
            // toastr.error(res.data);
            // }

            await $scope.shortcut.bind();
        }

        $scope.app.tab = {};
        $scope.app.tab.active = async (tab) => {
            $scope.app.tab.activetab = tab;
            await timeout();
        }

        $scope.app.delete = async () => {
            let app_id = $scope.app.id;
            await API.delete(app_id);
            await $scope.browse.load();
            if ($scope.browse.data[0]) {
                app_id = $scope.browse.data[0].package.id;
                location.href = APP_URL + "editor/" + app_id;
            } else {
                location.href = APP_URL;
            }
        }

        $scope.app.load = async (item) => {
            // show loading
            await $scope.loading.show();

            // load data
            $scope.app.data = item;
            await $scope.app.editor.build();
            await $scope.layout.change($scope.layout.active_layout);
            await $scope.loading.hide();
            
            // await $scope.app.preview();

            await timeout(500);

            if ($scope.app.tab.activetab && $scope.app.editor.cache[$scope.app.tab.activetab])
                $scope.app.editor.cache[$scope.app.tab.activetab].focus();

            // location.href = location.pathname + "#" + app_id;
        }

        $scope.app.preview = async () => {
            let url = $scope.app.data.package.viewuri;
            if (!$scope.app.data.package.viewuri) {
                url = await PREVIEW_URL($scope.app.id);
            }

            if (!url) {
                return;
            }

            $scope.app.preview.status = false;
            await timeout();

            $('iframe.preview').attr('src', url);
            $('iframe.preview').on('load', function () {
                $scope.app.preview.status = true;
                $timeout();
            });
        }
    }

    BUILDER.app.editor = async () => {
        $scope.app.editor = {};
        $scope.app.editor.cache = {};
        $scope.app.editor.properties = {};
        $scope.app.editor.code = {};

        $scope.app.editor.code.list = CODELIST;

        $scope.app.editor.code.dic = {};
        $scope.app.editor.code.dic.add = async (lang) => {
            if (!lang || lang.length < 2) {
                toastr.error("at least 2 char");
                return;
            }
            lang = lang.toLowerCase();
            $scope.app.data.dic[lang] = "{}";
            $('#modal-add-language').modal('hide');
            await timeout();
        }

        $scope.app.editor.code.langselect = async (tab) => {
            let obj = $scope.configuration.tab[tab + '_val'];
            if (obj == 'css') return 'scss';
            if (obj == 'html') return 'pug';
            if (obj == 'js') return 'javascript';
            return 'python';
        }

        $scope.app.editor.code.change = async (targettab, view) => {
            if (view) {
                $scope.configuration.tab[targettab + '_val'] = view;
                await timeout();

                if (view == 'preview') {
                    $scope.app.preview();
                    return;
                }

                if (view == 'debug') {
                    return;
                };

                let language = $scope.app.editor.properties[targettab].language = await $scope.app.editor.code.langselect(targettab);

                if ($scope.app.editor.cache[targettab]) {
                    let model = $scope.app.editor.cache[targettab].getModel();
                    monaco.editor.setModelLanguage(model, language);

                    $scope.app.editor.cache[targettab].focus();
                }
            } else {
                if ($scope.app.tab.activetab != targettab) {
                    $scope.app.tab.activetab = targettab;
                    await timeout();
                    await timeout(500);
                    $scope.app.editor.cache[targettab].focus();
                }
            }
        }

        $scope.app.editor.code.prev = async () => {
            if (!$scope.layout.accessable_tab) return;
            let tab = 'tab1';
            if ($scope.app.tab.activetab) tab = $scope.app.tab.activetab;

            tab = $scope.layout.accessable_tab.indexOf(tab) - 1;
            if (tab < 0) tab = $scope.layout.accessable_tab.length - 1;
            tab = $scope.layout.accessable_tab[tab];
            let view = $scope.configuration.tab[tab + '_val']

            while (view == 'preview') {
                tab = $scope.layout.accessable_tab.indexOf(tab) - 1;
                if (tab < 0) tab = $scope.layout.accessable_tab.length - 1;
                tab = $scope.layout.accessable_tab[tab];
                view = $scope.configuration.tab[tab + '_val']
            }

            $scope.app.editor.code.change(tab);
            $scope.app.editor.cache[tab].focus();
        }

        $scope.app.editor.code.next = async () => {
            if (!$scope.layout.accessable_tab) return;
            let tab = 'tab1';
            if ($scope.app.tab.activetab) tab = $scope.app.tab.activetab;

            tab = $scope.layout.accessable_tab.indexOf(tab) + 1;
            tab = tab % $scope.layout.accessable_tab.length;
            tab = $scope.layout.accessable_tab[tab];
            let view = $scope.configuration.tab[tab + '_val']

            while (view == 'preview') {
                tab = $scope.layout.accessable_tab.indexOf(tab) + 1;
                tab = tab % $scope.layout.accessable_tab.length;
                tab = $scope.layout.accessable_tab[tab];
                view = $scope.configuration.tab[tab + '_val']
            }

            $scope.app.editor.code.change(tab);
            $scope.app.editor.cache[tab].focus();
        }

        $scope.app.editor.build = async () => {
            $scope.app.editor.viewstate = false;
            await timeout();

            $scope.app.editor.properties.tab1 = $scope.monaco(await $scope.app.editor.code.langselect('tab1'));
            $scope.app.editor.properties.tab2 = $scope.monaco(await $scope.app.editor.code.langselect('tab2'));
            $scope.app.editor.properties.tab3 = $scope.monaco(await $scope.app.editor.code.langselect('tab3'));

            let bindonload = async (targettab) => {
                $scope.app.editor.properties[targettab].onLoad = async (editor) => {
                    await $scope.plugin.editor.build(targettab, editor);
                    $scope.app.editor.cache[targettab] = editor;
                }
            }

            for (var i = 1; i <= 3; i++)
                bindonload('tab' + i);

            $scope.app.editor.viewstate = true;
            await timeout();
        }

    }

    BUILDER.dataset = async () => {
        $scope.dataset.load = async () => {
            let res = await wiz.API.async("dataset", { namespace: wiz.data.namespace });
            console.log(res);
            $scope.dataset.data = res.data.data;
            await timeout();
        }

        $scope.dataset.select = async (item) => {
            await $scope.app.load(item);
        }
    }

    BUILDER.shortcuts = async () => {
        $scope.shortcut.configuration = (monaco) => {
            return {
                'editor_prev': {
                    monaco: monaco.KeyMod.Alt | monaco.KeyCode.KEY_A,
                    fn: async () => {
                        let targettab = $scope.app.tab.activetab;
                        var prev = TABS.indexOf($scope.configuration.tab[targettab + "_val"]) - 1;
                        if (prev < 0) prev = TABS[TABS.length - 1];
                        else prev = TABS[prev];

                        if (prev == 'preview') {
                            prev = TABS.indexOf(prev) - 1;
                            if (prev < 0) prev = TABS[TABS.length - 1];
                            else prev = TABS[prev];
                        }

                        await $scope.app.editor.code.change(targettab, prev);
                        await $scope.shortcut.bind();
                    }
                },
                'editor_next': {
                    monaco: monaco.KeyMod.Alt | monaco.KeyCode.KEY_S,
                    fn: async () => {
                        let targettab = $scope.app.tab.activetab;
                        var next = TABS[(TABS.indexOf($scope.configuration.tab[targettab + "_val"]) + 1) % TABS.length];
                        if (next == 'preview') {
                            next = TABS[(TABS.indexOf(next) + 1) % TABS.length];
                        }
                        await $scope.app.editor.code.change(targettab, next);
                        await $scope.shortcut.bind();
                    }
                },
                'app_prev': {
                    key: 'Alt KeyJ',
                    monaco: monaco.KeyMod.Alt | monaco.KeyCode.KEY_J,
                    fn: async () => {
                        $(window).focus();
                        await $scope.browse.prev();
                    }
                },
                'app_next': {
                    key: 'Alt KeyK',
                    monaco: monaco.KeyMod.Alt | monaco.KeyCode.KEY_K,
                    fn: async () => {
                        $(window).focus();
                        await $scope.browse.next();
                    }
                },
                'workspace_prev': {
                    key: 'Alt KeyZ',
                    monaco: monaco.KeyMod.Alt | monaco.KeyCode.KEY_Z,
                    fn: async () => {
                        await $scope.app.editor.code.prev();
                    }
                },
                'workspace_next': {
                    key: 'Alt KeyX',
                    monaco: monaco.KeyMod.Alt | monaco.KeyCode.KEY_X,
                    fn: async () => {
                        await $scope.app.editor.code.next();
                    }
                },
                'save': {
                    key: 'Ctrl KeyS',
                    monaco: monaco.KeyMod.CtrlCmd | monaco.KeyCode.KEY_S,
                    fn: async () => {
                        await $scope.app.save();
                    }
                },
                'clear': {
                    key: 'Ctrl KeyK',
                    monaco: monaco.KeyMod.CtrlCmd | monaco.KeyCode.KEY_K,
                    fn: async () => {
                        await $scope.socket.clear();
                    }
                }
            }
        };

        $scope.shortcut.bind = async () => {
            if (!window.monaco) return;
            $(window).unbind();

            let shortcut_opts = {};
            let shortcuts = $scope.shortcut.configuration(window.monaco);
            for (let key in shortcuts) {
                let keycode = shortcuts[key].key;
                let fn = shortcuts[key].fn;
                if (!keycode) continue;
                shortcut_opts[keycode] = async (ev) => {
                    ev.preventDefault();
                    await fn();
                };
            }

            shortcutjs(window, shortcut_opts);
        }

        window.addEventListener("focus", $scope.shortcut.bind, false);
    }

    await BUILDER.loading();
    await BUILDER.layout();
    await BUILDER.plugin();
    await BUILDER.modal();

    await BUILDER.workspace();

    await BUILDER.dataset();

    await BUILDER.app.base();
    await BUILDER.app.editor();

    await BUILDER.shortcuts();

    let init = async () => {
        await $scope.dataset.load();
        await $scope.dataset.select($scope.dataset.data[0]);

        return
        /*
         * socket.io event binding for trace log
         */
        let ansi_up = new AnsiUp();
        let socket = io("/wiz");

        $scope.socket.log = "";
        $scope.socket.clear = async () => {
            $scope.socket.log = "";
            await API.timeout();
        }

        $scope.socket.link = async () => {
            let layout = $scope.configuration.layout;
            await $scope.layout.change(layout - 3);
            window.open("/wiz/admin/workspace/logger", '_blank');
        }

        socket.on("connect", function (data) {
            if (!data) return;
            $scope.socket.id = data.sid;
        });

        socket.on("log", function (data) {
            data = data.replace(/ /gim, "__SEASONWIZPADDING__");
            data = ansi_up.ansi_to_html(data).replace(/\n/gim, '<br>').replace(/__SEASONWIZPADDING__/gim, '<div style="width: 6px; display: inline-block;"></div>');
            $scope.socket.log = $scope.socket.log + data;
            $timeout(function () {
                var element = $('.debug-messages')[0];
                if (!element) return;
                element.scrollTop = element.scrollHeight - element.clientHeight;
            });
        });

        socket.on("message", function (data) {
            if (data.type == "status") {
                $scope.socket.users = data.users;
                $timeout();
            }
        });

        $scope.$watch("configuration", async () => {
            let layout = $scope.configuration.layout;
            if (layout < 4) {
                socket.emit("leave", { id: BRANCH });
            } else {
                socket.emit("join", { id: BRANCH });
            }
        }, true);
    }

    init();
}